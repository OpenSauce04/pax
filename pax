#!/usr/bin/env ruby

version = "0.0.0"

mode_sync = false
mode_refresh = false
mode_upgrade = false
mode_clean = false

mode_remove = false
mode_autoremove = false
mode_purge = false

mode_container = false
mode_initcontainer = false
mode_exportcontainer = false
mode_unexportcontainer = false
mode_enter = false
mode_runcontainer = false

mode_verbose = false
mode_test = false

packages = []

def bold(str) return "\033[1m" + str + "\033[0m" end

def showHelp()
  puts "\n            " + bold("pax") + "\napx with pacman-like syntax\n\n"
  puts bold("Select container [@]")
  puts "  "+bold('@')+"[distro]"
  puts "  Available:"
  puts "    apt - Ubuntu"
  puts "    aur - Arch + AUR"
  puts "    dnf - Fedora"
  puts "    apk - Alpine"
  puts "    zypper - openSUSE"
  puts "    xbps - Void"
  puts "    nix - Nixpkgs"
  puts
  puts bold("Options [-]")
  puts "  "+bold('S')+" - Install package(s) / Installation-related operations"
  puts "    "+bold('y')+" - Update package list"
  puts "    "+bold('u')+" - Upgrade all available packages"
  puts "    "+bold('c')+" - Clean package manager cache"
  puts
  puts "  "+bold('R')+" - Remove package(s) / Removal-related operations"
  puts "    "+bold('u')+" - Remove all unused packages"
  puts "    "+bold('p')+" - Purge removed package(s)"
  puts
  puts "  "+bold('C')+" - Container-related operations"
  puts "    "+bold('i')+" - Initialize a container"
  puts "    "+bold('s')+" - Export container package"
  puts "    "+bold('u')+" - Un-export container package"
  puts "    "+bold('e')+" - Enter container"
  puts "    "+bold('x')+" - Execute program within a container"
  puts
  puts "  "+bold('v')+" - Show translated apx command that is executed by pax"
  puts "  "+bold('t')+" - Do not execute the translated command"
  puts "  "+bold('h')+" - Help | Show this message"
  puts
  puts bold("Example")
  puts "$ pax -Ru && pax @apt -Syu wine"
  puts "Removes all unused packages, updates package lists, upgrades available packages, then installs wine in the Ubuntu container"
  puts
  exit 0
end

distro = "NONE"

# Parse command line arguments
ARGV.each do|arg|

  if arg.start_with?('@')
    distro = arg.sub('@', "--")
    next
  end

  isOps = arg.start_with?('-')

  if isOps # Parse as options

    arg.split("").drop(1).each do |char|

      if arg.include?('V')
        puts "\n         " + bold("pax v" + version) + "\napx with pacman-like syntax\n\n"
        exit 0
      end

      case char

        when 'S'
          mode_sync = true
        when 'y'
          mode_refresh = true
        when 'u'
          mode_upgrade = true
          mode_autoremove = true # As this is a switch case, mode flags that use the same key need to be in the same "when"
        when 'c'
          mode_clean = true

        when 'R'
          mode_remove = true
        #when 'u'
          #mode_autoremove = true
        when 'p'
          mode_purge = true

        when 'C'
          mode_container = true
        when 's'
          mode_exportcontainer = true
        when 'u'
          mode_unexportcontainer = true
        when 'e'
          mode_entercontainer = true
        when 'i'
          mode_initcontainer = true
        when 'x'
          mode_runcontainer = true

        when 'v'
          mode_verbose = true
        when 't'
          mode_test = true
        when 'h'
          showHelp()

        else
          puts "error: invalid option '" + bold(char) + "'"
          exit 1
    end

  end

  else # Parse as package names

    packages.append(arg)

  end

end

# Validate mode combination
if ((mode_sync || mode_refresh || mode_clean) && !mode_sync) \
|| (mode_autoremove && !mode_remove && !mode_sync) \
|| (mode_sync ^ mode_remove ? mode_container : mode_sync) # Magic 3-way comparison I found on Stack Overflow
  STDERR.puts "error: invalid option combination"
  exit 1
end

# Build the command that will be executed
PRE = "apx "
if distro != "NONE"
  PRE << distro+' '
end

POST = " && "

command = ""

# Sync operations
command << PRE + "clean" + POST if mode_clean && mode_sync
command << PRE + "update" + POST if mode_refresh && mode_sync
command << PRE + "upgrade" + POST if mode_upgrade && mode_sync
command << PRE + "install " + packages.join(" ") + POST if mode_sync

# Remove operations
command << PRE + "remove " + packages.join(" ") + POST if !mode_purge && !mode_autoremove && mode_remove
command << PRE + "purge " + packages.join(" ") + POST if mode_purge && mode_remove
command << PRE + "autoremove" + POST if mode_autoremove && mode_remove

# Container operations
command << PRE + "init " + packages.join(" ") + POST if mode_initcontainer && mode_container
command << PRE + "export " + packages.join(" ") + POST if mode_exportcontainer && mode_container
command << PRE + "unexport " + packages.join(" ") + POST if mode_unexportcontainer && mode_container
command << PRE + "enter " + packages.join(" ") + POST if mode_exportcontainer && mode_container
command << PRE + "run " + packages.join(" ") + POST if mode_runcontainer && mode_container

command = command[0...-3] # Cut final " &&"

puts command if mode_verbose

exec(command) if !mode_test